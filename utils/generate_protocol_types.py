"""
CLI script to generate Protocol types
"""
import asyncio
import json
import logging
import re
import time
from datetime import datetime
from textwrap import dedent
from typing import Dict, Any, Hashable, Match, List, Union

from pyppeteer import launch

handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('[{levelname}] {name}: {message}', style='{'))
logging.getLogger('pyppeteer.connection.Connection').setLevel(logging.ERROR)
logging.getLogger('pyppeteer').addHandler(handler)

logger = logging.getLogger(__name__)
logger.addHandler(handler)
logger.setLevel(logging.INFO)
handler.setLevel(logging.INFO)


async def main():
    browser = await launch(args=['--no-sandbox', '--disable-setuid-sandbox'])
    base_endpoint = re.search(r'ws://([0-9A-Za-z:.]*)/', browser.wsEndpoint).group(1)
    page = await browser.newPage()

    logger.info(f'Loading protocol into memory')
    t_start = time.perf_counter()
    await page.goto(f'http://{base_endpoint}/json/protocol')
    page_content = await page.evaluate('document.documentElement.innerText')
    try:
        await browser.close()
    except:
        pass
    logger.info(f'Loaded protocol into memory in {time.perf_counter()-t_start:.2f}s')

    t_start = time.perf_counter()
    logger.info(f'Parsing protocol spec')
    domains = json.loads(page_content)['domains']
    indent_manager = IndentManager()
    code_gen = TypingCodeGenerator(indent_manager)
    typed_dicts = []
    all_known_types = {}

    header = f'''\
        Automatically generated by ./utils/generate_protocol_types
        Attention! This file should not be modified directly! Instead, use the script to create it. 

        Last regeneration: {datetime.utcnow()}'''

    code_gen.insert_before_code('"""')
    code_gen.insert_before_code(header)
    code_gen.insert_before_code('"""')
    code_gen.add_newlines(num=2)

    code_gen.add('class Protocol:')
    with indent_manager:
        for domain in domains:
            domain_name = domain["domain"]
            code_gen.add_comment_if_desc_exists(domain)
            code_gen.add(f'class {domain_name}:')
            all_known_types[domain_name] = domain_known_types = {}
            with indent_manager:
                for type_info in domain.get('types', []):
                    code_gen.add_comment_if_desc_exists(type_info)
                    item_name = type_info["id"]
                    if 'properties' in type_info:
                        # mangle names to avoid naming collisions
                        type_info["id"] = f'_{domain_name}_{type_info["id"]}'
                        _type = type_info["id"]
                        typed_dicts.append(generate_typed_dict(type_info, domain_name, 'properties'))
                    else:
                        _type = convert_js_to_py_type(type_info, domain_name)

                    domain_known_types[item_name] = _type
                    code_gen.add(f'{item_name} = {_type}')

                for command_info in domain.get('commands', []):
                    item_name = command_info["name"]
                    code_gen.add_comment_if_desc_exists(command_info)
                    if 'parameters' in command_info:
                        _type = f'{command_info["name"]}_{domain_name}_Parameters'
                        typed_dicts.append(generate_typed_dict(command_info, domain_name, 'parameters', name=_type))
                    else:
                        _type = 'None'

                    domain_known_types[f'{item_name}Parameters'] = _type
                    code_gen.add(f'{item_name}Parameters = {_type}')

                    if 'returns' in command_info:
                        _type = f'{command_info["name"]}_{domain_name}_ReturnValue'
                        typed_dicts.append(generate_typed_dict(command_info, domain_name, 'returns', name=_type))
                    else:
                        _type = 'None'

                    domain_known_types[f'{item_name}ReturnValue'] = _type
                    code_gen.add(f'{item_name}ReturnValue = {_type}')

                code_gen.add_newlines(num=1)

        # todo: events

    # all typed dicts are inserted prior to the main Protocol class
    for td in typed_dicts:
        td.add_newlines(num=2)
        code_gen.insert_before_code(td)

    def resolve_forward_ref(match: Match) -> str:
        ref, domain_ = None, None
        try:
            domain_, ref = match.group(1).split('.')
            forward_ref = all_known_types[domain_][ref]

            # resolve nested forward references
            if re.search(forward_ref_re, forward_ref):
                forward_ref = resolve_forward_ref_in_line(forward_ref)
            if forward_ref not in js_to_py_types.values() and not forward_ref.startswith('Literal'):
                # forward ref to a typed dict, not sure that it will be defined
                forward_ref = f'\'{forward_ref}\''
        except KeyError:
            logger.warning(f'Protocol.{domain_}{"." + ref if ref else ""} forward reference type not found')
            forward_ref = match.group(0)
        except ValueError:  # too few values to unpack, ie malformed forward reference
            raise ValueError(f'Forward reference not nested as expected (forward reference={match.group(0)})')

        return forward_ref

    forward_ref_re = r'\'Protocol\.(\w+\.\w+)\''

    def resolve_forward_ref_in_line(line_):
        return re.sub(forward_ref_re, resolve_forward_ref, line_)

    # no need for copying list as we aren't adding/removing elements
    # resolve forward refs in main protocol class
    for index, line in enumerate(code_gen.code_lines):
        # skip empty lines or lines positively without forward reference
        if not line.strip() or 'Protocol' not in line:
            continue
        code_gen.code_lines[index] = resolve_forward_ref_in_line(line)

    # resolve forward refs in main protocol class
    for index, line in enumerate(code_gen.inserted_lines):
        # skip empty lines or lines positively without forward reference
        if not line.strip() or 'Protocol' not in line:
            continue
        code_gen.inserted_lines[index] = resolve_forward_ref_in_line(line)

    # todo: expand cyclic references n-times

    logger.info(f'Parsed protocol spec in {time.perf_counter()-t_start:.2f}s')
    # newline at end of file
    code_gen.add_newlines(num=1)
    with open('protocol.py', 'w') as p:
        p.write(str(code_gen))


def generate_typed_dict(type_info: Dict[str, Any], domain_name: str, prop_key: str, name: str = None) -> 'TypedDictGenerator':
    td_name = name or multi_fallback_get(type_info, 'id', 'name')
    is_total = any(1 for x in type_info[prop_key] if x.get('optional'))
    indent_mgr = IndentManager()
    td = TypedDictGenerator(td_name, is_total, indent_mgr)
    with indent_mgr:
        for item in type_info[prop_key]:
            td.add_comment_if_desc_exists(item)
            td.add_item(item['name'], convert_js_to_py_type(item, domain_name))
    return td


def multi_fallback_get(d: Dict[Hashable, Any], *k, default=-1):
    for key in k:
        if key in d:
            return d[key]
    if default == -1:
        raise KeyError(f'{", ".join(k)} all not found in {d}')
    return default


js_to_py_types = {
    'any': 'Any',
    'string': 'str',
    'object': 'Dict[str, str]',
    'boolean': 'bool',
    'number': 'float',
    'integer': 'int',
    'binary': 'bytes',
}


def convert_js_to_py_type(type_info, domain_name) -> str:
    if type(type_info) == str:
        return js_to_py_types[type_info]

    if type_info.get('items'):
        assert type_info['type'] == 'array'
        if '$ref' in type_info['items']:
            ref = type_info["items"]["$ref"]
            _type = f'List[{get_forward_ref(ref, domain_name)}]'
        else:
            _type = f'List[{convert_js_to_py_type(type_info["items"]["type"], domain_name)}]'
    else:
        if '$ref' in type_info:
            _type = get_forward_ref(type_info["$ref"], domain_name)
        else:
            if type_info.get('enum'):
                if type_info['type'] != 'string':
                    raise ValueError('enum without string')
                _enum_vals = ", ".join([f'\'{x}\'' for x in type_info["enum"]])
                _type = f'Literal[{_enum_vals}]'
            else:
                _type = js_to_py_types[type_info['type']]

    return _type


def get_forward_ref(ref: str, potential_context: str):
    is_relative_to_context = len(ref.split('.')) == 2
    # eg Domain.Something
    if len(ref.split('.')) == 2:
        non_fw_ref = f'Protocol.{ref}'
    # eg Something, ie requires context
    else:
        non_fw_ref = f'Protocol.{potential_context}.{ref}'
    return f'\'{non_fw_ref}\''


class TypingCodeGenerator:
    def __init__(self, indent_mgr: 'IndentManager'):
        self.indent_mgr = indent_mgr
        self.import_lines = []
        self.inserted_lines = []
        self.code_lines = []
        self.lines_classification = 'code'
        self.init_imports()

    def init_imports(self):
        self.lines_classification = 'import'
        self.add('import sys')
        self.add_newlines(num=1)
        self.add('from typing import List, Dict, Any')
        self.add_newlines(num=1)
        self.add('if sys.version_info < (3,8):')
        with self.indent_mgr:
            self.add('from typing_extensions import Literal, TypedDict')
        self.add('else:')
        with self.indent_mgr:
            self.add('from typing import Literal, TypedDict')
        self.add_newlines(num=2)
        self.lines_classification = 'code'

    def add_newlines(self, num: int = 1):
        self.add('\n' * num)

    def add_comment_if_desc_exists(self, info: Dict[str, Any]):
        if info.get('description'):
            newline = '\n'
            self.add(f'# {info["description"].replace(newline, "")}')

    def add(self, code: str = None, lines: List[str] = None):
        if code:
            preprocessed = [line for line in dedent(code).split('\n')]
            lines = [f'{self.indent_mgr}{li}' for li in preprocessed]
        self.__getattribute__(f'{self.lines_classification}_lines').extend(lines)

    def insert_before_code(self, other: Union['TypingCodeGenerator', 'str']):
        self.lines_classification = 'inserted'
        if isinstance(other, str):
            self.add(other)
        else:
            self.add(lines=other.code_lines)
        self.lines_classification = 'code'

    def __str__(self):
        return '\n'.join(self.import_lines) + '\n'.join(self.inserted_lines) + '\n'.join(self.code_lines)

    def __repr__(self):
        return f'<TypingCodeGenerator with {len(self.code_lines)} LOC>'


class TypedDictGenerator(TypingCodeGenerator):
    def __init__(self, name: str, total: bool, indent_mgr: 'IndentManager'):
        super().__init__(indent_mgr)
        total_spec = ', total=False' if total else ''
        self.add(f'class {name}(TypedDict{total_spec}):')

    def init_imports(self):
        pass

    def add_item(self, name: str, _type: str):
        super().add(f'{name}: {_type}')

    def __hash__(self):
        return hash(''.join(self.code_lines))


class IndentManager:
    def __init__(self):
        self._indent = ''

    def __enter__(self):
        self._indent += '    '

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._indent = self._indent[:-4]

    def __str__(self):
        return self._indent


asyncio.get_event_loop().run_until_complete(main())
