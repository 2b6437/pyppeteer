"""
CLI script to generate Protocol types
"""
import asyncio
import json
import logging
import re
from datetime import datetime
from textwrap import dedent
from typing import Dict, Any, Hashable, Match, List, Union

from pyppeteer import launch


handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('[{levelname}] {name}: {message}', style='{'))
handler.addFilter(lambda x: 'Event' in x.msg)
logging.getLogger('pyppeteer').addHandler(handler)
logging.getLogger('pyppeteer.connection.Connection').setLevel(logging.ERROR)

logger = logging.getLogger(__name__)


async def main():
    browser = await launch(args=['--no-sandbox', '--disable-setuid-sandbox'])
    base_endpoint = re.search(r'ws://([0-9A-Za-z:.]*)/', browser.wsEndpoint).group(1)
    page = await browser.newPage()
    await page.goto(f'http://{base_endpoint}/json/protocol')
    domains = json.loads(await page.evaluate('document.documentElement.innerText'))['domains']
    indent_manager = IndentManager()
    code_gen = TypingCodeGenerator(indent_manager)
    typed_dicts = []
    all_known_types = {}
    code_gen.insert_before_code('"""')
    code_gen.insert_before_code(
        f'''Automatically generated by ./utils/generate_protocol_types
            Attention! This file should not be modified directly! Instead, use the script to create it. 

            Last regeneration: {datetime.utcnow()}'''
    )
    code_gen.insert_before_code('"""')

    code_gen.add('class Protocol:')
    with indent_manager:
        for domain in domains:
            domain_name = domain["domain"]
            code_gen.add_comment_if_desc_exists(domain)
            code_gen.add(f'class {domain_name}:')
            all_known_types[domain_name] = domain_known_types = {}
            with indent_manager:
                for type_info in domain.get('types', []):
                    code_gen.add_comment_if_desc_exists(type_info)
                    item_name = type_info["id"]
                    if 'properties' in type_info:
                        _type = item_name
                        typed_dicts.append(generate_typed_dict(type_info, domain_name, 'properties'))
                    else:
                        _type = convert_js_to_py_type(type_info, domain_name)

                    domain_known_types[item_name] = _type
                    code_gen.add(f'{item_name} = {_type}')

                for command_info in domain.get('commands', []):
                    item_name = command_info["name"]
                    code_gen.add_comment_if_desc_exists(command_info)
                    if 'parameters' in command_info:
                        command_info['name'] = command_info['name'] + domain_name + 'P'
                        _type = command_info["name"]
                        typed_dicts.append(generate_typed_dict(command_info, domain_name, 'parameters'))
                    else:
                        _type = 'None'

                    domain_known_types[item_name] = _type
                    code_gen.add(f'{item_name}Parameters = {_type}')

                    if 'returns' in command_info:
                        command_info['name'] = command_info['name'] + domain_name + 'R'
                        _type = command_info["name"]
                        typed_dicts.append(generate_typed_dict(command_info, domain_name, 'returns'))
                    else:
                        _type = 'None'

                    domain_known_types[item_name] = _type
                    code_gen.add(f'{item_name}ReturnValue = {_type}')

                code_gen.add_newlines(num=1)

        # code_gen.add('class Events:')
        # with indent_manager:
        #     for event_domain, events in [(d['domain'], d.get('events', [])) for d in domains]:
        #         code_gen.add(f'class {event_domain}:')
        #         with indent_manager:
        #             for event in events:
        #                 code_gen.add(f'{event} = {})
    for td in typed_dicts:
        td.add_newlines(num=2)
        code_gen.insert_before_code(td)

    def replace_forward_reference(match: Match) -> str:
        ref, domain_ = None, None
        try:
            domain_, ref = match.group(1).split('.')
            forward_ref = all_known_types[domain_][ref]
            if forward_ref not in js_to_py_types.values() and not forward_ref.startswith('Literal'):
                # forward ref to a typed dict, not sure that it will be defined
                forward_ref = f'\'{forward_ref}\''
        except KeyError:
            logger.warning(f'Protocol.{domain_}{"." + ref if ref else ""} forward reference type not found')
            forward_ref = match.group(0)
        except ValueError:  # too few values to unpack, ie malformed forward reference
            raise ValueError(f'Forward reference not nested as expected (forward reference={match.group(0)})')

        return forward_ref

    forward_ref_re = r'\'Protocol\.(\w+\.\w+)\''
    # no need for copying list as we aren't adding/removing elements
    for index, line in enumerate(code_gen.code_lines):
        if not line.strip() or 'Protocol' not in line:
            continue
        code_gen.code_lines[index] = re.sub(forward_ref_re, replace_forward_reference, line)

    for index, line in enumerate(code_gen.inserted_lines):
        if not line.strip() or 'Protocol' not in line:
            continue
        code_gen.inserted_lines[index] = re.sub(forward_ref_re, replace_forward_reference, line)

    code_gen.add_newlines(num=1)
    with open('protocol.py', 'w') as p:
        p.write(str(code_gen))
    pass


def generate_typed_dict(type_info: Dict[str, Any], domain_name: str, prop_key: str) -> 'TypedDictGenerator':
    td_name = multi_fallback_get(type_info, 'id', 'name')
    is_total = any([1 for x in type_info[prop_key] if x.get('optional')])
    indent_mgr = IndentManager()
    td = TypedDictGenerator(td_name, is_total, indent_mgr)
    with indent_mgr:
        for item in type_info[prop_key]:
            td.add_comment_if_desc_exists(item)
            td.add_item(item['name'], convert_js_to_py_type(item, domain_name))
    return td


def multi_fallback_get(d: Dict[Hashable, Any], *k, default=-1):
    for key in k:
        if key in d:
            return d[key]
    if default == -1:
        raise KeyError(f'{", ".join(k)} all not found in {d}')
    return default


js_to_py_types = {
    'any': 'Any',
    'string': 'str',
    'object': 'Dict[str, str]',
    'boolean': 'bool',
    'number': 'float',
    'integer': 'int',
    'binary': 'bytes',
}


def convert_js_to_py_type(type_info, domain_name) -> str:
    if type(type_info) == str:
        return js_to_py_types[type_info]

    if type_info.get('items'):
        assert type_info['type'] == 'array'
        if '$ref' in type_info['items']:
            ref = type_info["items"]["$ref"]
            _type = f'List[{get_forward_ref(ref, domain_name)}]'
        else:
            _type = f'List[{convert_js_to_py_type(type_info["items"]["type"], domain_name)}]'
    else:
        if '$ref' in type_info:
            _type = get_forward_ref(type_info["$ref"], domain_name)
        else:
            if type_info.get('enum'):
                if type_info['type'] != 'string':
                    raise ValueError('enum without string')
                _enum_vals = ", ".join([f'\'{x}\'' for x in type_info["enum"]])
                _type = f'Literal[{_enum_vals}]'
            else:
                _type = js_to_py_types[type_info['type']]

    return _type


def get_forward_ref(ref: str, potential_context: str):
    is_relative_to_context = len(ref.split('.')) == 2
    # eg Domain.Somethi
    if len(ref.split('.')) == 2:
        non_fw_ref = f'Protocol.{ref}'
    else:
        non_fw_ref = f'Protocol.{potential_context}.{ref}'
    return f'\'{non_fw_ref}\''


class TypingCodeGenerator:
    def __init__(self, indent_mgr: 'IndentManager'):
        self.indent_mgr = indent_mgr
        self.import_lines = []
        self.inserted_lines = []
        self.code_lines = []
        self.lines_classification = 'code'
        self.init_imports()

    def init_imports(self):
        self.lines_classification = 'import'
        self.add('import sys')
        self.add_newlines(num=1)
        self.add('from typing import List, Dict, Any')
        self.add_newlines(num=1)
        self.add('if sys.version_info < (3,8):')
        with self.indent_mgr:
            self.add('from typing_extensions import Literal, TypedDict')
        self.add('else:')
        with self.indent_mgr:
            self.add('from typing import Literal, TypedDict')
        self.add_newlines(num=2)
        self.lines_classification = 'code'

    def add_newlines(self, num: int = 1):
        self.add('\n' * num)

    def add_comment_if_desc_exists(self, info: Dict[str, Any]):
        if info.get('description'):
            newline = '\n'
            self.add(f'# {info["description"].replace(newline, "")}')

    def add(self, code: str = None, lines: List[str] = None):
        if code:
            preprocessed = [line for line in dedent(code).split('\n')]
            # makes sure that only n newlines are generated, not n+1
            if not preprocessed[-1]:
                preprocessed = preprocessed[:-1]
            lines = [f'{self.indent_mgr}{li}' for li in preprocessed]
        self.__getattribute__(f'{self.lines_classification}_lines').extend(lines)

    def insert_before_code(self, other: Union['TypingCodeGenerator', 'str']):
        self.lines_classification = 'inserted'
        if isinstance(other, str):
            self.add(other)
        else:
            self.add(lines=other.code_lines)
        self.lines_classification = 'code'

    def __str__(self):
        return '\n'.join(self.import_lines) + '\n'.join(self.inserted_lines) + '\n'.join(self.code_lines)

    def __repr__(self):
        return f'<TypingCodeGenerator with {len(self.code_lines)} LOC>'


class TypedDictGenerator(TypingCodeGenerator):
    def __init__(self, name: str, total: bool, indent_mgr: 'IndentManager'):
        super().__init__(indent_mgr)
        total_spec = ', total=False' if total else ''
        self.add(f'class {name}(TypedDict{total_spec}):')

    def init_imports(self):
        pass

    def add_item(self, name: str, _type: str):
        super().add(f'{name}: {_type}')

    def __hash__(self):
        return hash(''.join(self.code_lines))


class IndentManager:
    def __init__(self):
        self._indent = ''

    def __enter__(self):
        self._indent += '    '

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._indent = self._indent[:-4]

    def __str__(self):
        return self._indent


asyncio.get_event_loop().run_until_complete(main())
